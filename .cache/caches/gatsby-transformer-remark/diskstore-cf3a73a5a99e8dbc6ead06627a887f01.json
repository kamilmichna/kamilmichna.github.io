{"expireTime":9007200830448266000,"key":"transformer-remark-markdown-html-ebbc8ed7933909d2dd668fb0dc21f617-gatsby-remark-prismjs-","val":"<h1>Matura 2019 - Ulubione cyfry</h1>\n<p>Cześć! Nowa seria polegać będzie na wspólnym rozwiązywaniu zadań z matury rozszerzonej z informatyki, do której właśnie się przygotowuję. Wykorzystywać będziemy język <strong>Python</strong> - jako jeden z dostępnych obecnie. Zaczniemy od tegorocznej matury. Arkusze matury możesz znaleźć na stronie Centralnej Komisji Egzaminacyjnej:  <a href=\"https://cke.gov.pl/egzamin-maturalny/egzamin-w-nowej-formule/arkusze/2019-2/\">Link</a>.</p>\n<h2>Treść zadania:</h2>\n<p><code class=\"language-text\">Małgosia i Jaś lubią liczby. Małgosia lubi liczby nieparzyste, a Jaś lubi liczby parzyste. Każde z dzieci zapisało po kilka spośród swoich ulubionych liczb na jednej wspólnej kartce. Najpierw Małgosia zapisała wszystkie swoje liczby, a potem Jaś dopisał swoje.</code>\n\"Kartkę\" możemy przedstawić jako <strong>tablicę dwuwymiarową</strong> która zawiera najpierw bliżej nieokreśloną ilość liczb nieparzystych, a następnie - również nieokreśloną ilość liczb parzystych. Dla przykładu, zbiór liczb wypisanych przez Jasia i Małgosie może wyglądać w ten sposób:\n<code class=\"language-text\">{5, 99, 3, 7, 111, 13, 4, 24, 4, 8}</code>\nOd lewej mamy zapisane liczby Małgosi - nieparzyste. Naszym celem jest znalezienie pierwszej liczby Jasia - czyli pierwszej liczby parzystej. W tym przypadku jest to <strong>4</strong>.</p>\n<h2>Zadanie 1.1:</h2>\n<p>`\nNapisz algorytm (w postaci listy kroków, w pseudokodzie lub w wybranym języku programowania), który dla danego ciągu liczb zapisanych przez dzieci znajdzie pierwszą liczbę zapisaną przez Jasia. Zakładamy, że każde z dzieci zapisało co najmniej jedną liczbę. </p>\n<p>Przy ocenie będzie brana pod uwagę złożoność czasowa Twojego algorytmu. Maksymalną liczbę punktów uzyskasz za algorytm o złożoności lepszej niż liniowa. </p>\n<p>Uwaga: W zapisie algorytmu możesz wykorzystać tylko operacje arytmetyczne (dodawanie, odejmowanie, mnożenie, dzielenie, dzielenie całkowite, reszta z dzielenia), instrukcje porównania, instrukcje sterujące i przypisania do zmiennych lub samodzielnie napisane funkcje, wykorzystujące wyżej wymienione operacje.\n`\nO co chodzi? Ano mamy za zadanie napisać w <strong>dowolnym języku programowania lub pseudokodzie</strong> program który w ciągu liczb znajdzie nam pierwszą liczbę parzystą (napisaną przez Jasia). Jest to stosunkowo proste na pierwszy rzut oka, ale sprawa komplikuje się przy <strong>złożoności obliczeniowej</strong>. Wykonajmy więc póki co zadanie w najprostszy sposób, taki po \"najmniejszej linii oporu\"  - najszybszy ale jednocześnie dający nam najmniejszą liczbę punktów.</p>\n<p>W jaki sposób to zrobimy? Pewnie większość z Was gdyby bez względu na wspomnianą już <strong>złożoność obliczeniową</strong> miała napisać wymagany algorytm zrobiła by to w ten sposób. po prostu sprawdzamy naszą tablicę od lewej do prawej, i gdy tylko natrafimy na liczbę parzystą zatrzymujemy go i zwracamy wynik. Użyjemy do tego <strong>pętli</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># używam polskiej nazwy zmiennej jedynie dla lepszej czytelności kodu.</span>\nlista <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">99</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">111</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">24</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">for</span> liczba <span class=\"token keyword\">in</span> lista<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">if</span> liczba <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Pierwsza liczba parzysta to: '</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>liczba<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Myślę że kod jest bardzo prosty - i co ważne czytelny. Moglibyśmy również zrobić z niego funkcję która odnajdzie pierwszą liczbę parzystą dla każdego zbioru liczb podanego jako argument. Do dzieła!</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># używam polskiej nazwy zmiennej jedynie dla lepszej czytelności kodu.</span>\nlista <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">99</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">111</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">24</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">pierwsza_parzysta</span><span class=\"token punctuation\">(</span>liczby<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">for</span> liczba <span class=\"token keyword\">in</span> liczby<span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">if</span> liczba<span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token keyword\">return</span> liczba\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Pierwsza parzysta liczba to: '</span><span class=\"token operator\">+</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>pierwsza_parzysta<span class=\"token punctuation\">(</span>lista<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Program w obu powyższych przypadkach zwróci 4 - czyli działa. Kod jest czytelny, prosty, sukces, prawda? Ano nie. Rozwiązanie jest prawidłowe, ale dostalibyśmy za nie minimalną liczbę punktów. </p>\n<h2>Dlaczego?</h2>\n<p>Problemem jest  wspomniana już wcześniej <strong>złożoność obliczeniowa</strong>. O co chodzi? Ważnym problemem w informatyce jest opisanie szybkości danego programu. Jednak istnieje całe mnóstwo konfiguracji sprzętowych - zwyczajny pomiar czasu wykonania nie jest miarodajny. Dlatego używa się różnych sposobów na określenie szybkości działania algorytmu. W skrócie, nasz algorytm ma obecnie złożoność liniową. Dlaczego? Ano jeżeli narysowalibyśmy sobie wykres ilości przeprowadzonych operacji do ilości liczb to była by to linia prosta - im więcej liczb tym więcej razy musimy iterować przez tablicę. Lepszym rozwiązaniem jest zastosowanie algorytmu o złożoności logarytmicznej. Zapisany przeze mnie w pythonie algorytm wygląda w ten sposób: </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">A <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">22</span><span class=\"token punctuation\">,</span><span class=\"token number\">44</span><span class=\"token punctuation\">,</span><span class=\"token number\">18</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n\tn <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>  <span class=\"token keyword\">and</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#Otrzymaliśmy wynik, wyświetlamy go</span>\n\t\t<span class=\"token keyword\">break</span>\n\t<span class=\"token keyword\">elif</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>  <span class=\"token keyword\">and</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n\t\tA <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n\t<span class=\"token keyword\">elif</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>  <span class=\"token keyword\">and</span> A<span class=\"token punctuation\">[</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n\tA <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>n<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Co dzieje się w tym programie? Załóżmy że mamy tablicę: <code class=\"language-text\">1,2,5,6,22,44,18</code>. Program znajduje jej środek, czyli <code class=\"language-text\">6</code>. Następnie sprawdza wartość elementu wcześniejszego, czyli <code class=\"language-text\">5</code>. Jeżeli nasz  parzysty środek jest poprzedzony liczbą nieparzystą, oznacza to że znaleźliśmy poszukiwaną przez nas wartość. Sprawdźmy teraz działanie algorytmu na innym zbiorze danych, na przykład podanym wcześniej: <code class=\"language-text\">5, 99, 3, 7, 111, 13, 4, 24, 4, 8</code>. Program środek tablicy znajduje wzorem <code class=\"language-text\">długość tablicy//2</code>, czyli w naszym przypadku jest to indeks 5 - wartość <code class=\"language-text\">13</code>. Program sprawdza element poprzedzający - <code class=\"language-text\">111</code>. Instrukcja warunkowa nr 2 (środkowy elif) mówi mu, że w takim przypadku ma uciąć pierwszą połowę naszej tabeli - element szukany na pewno znajduje się bardziej na prawo! Następuje kolejna iteracja. Tym razem za środek zostaje przyjęty element o indeksie <code class=\"language-text\">2</code>, a A ma teraz elementy: <code class=\"language-text\">13, 4, 24, 4, 8</code>. 24 jest podzielne przez 2, element poprzedzający - 4 - też. W tym wypadku odcinamy wszystko na prawo, razem z 24. Pozostaje nam <code class=\"language-text\">[13,4]</code>, z którego program zwraca wartość 4 dzięki pierwszej instrukcji warunkowej. I  voilà! Użyliśmy tutaj wariacji algorytmu <code class=\"language-text\">binary search</code>, który według Wikipedii ma złożoność <strong>O(log n)</strong>. Oznacza to że <strong>w przypadku miliona elementów w tablicy program musiałby sprawdzić maksymalnie 20 elementów aby znaleźć pożądany, a nasz wcześniejszy algorytm - w najgorszym wypadku - aż milion!</strong> To gigantyczna przepaść w złożoności, ważna zwłaszcza w dużych zbiorach danych. Następnie pozostało nam udzielić odpowiedzi - złożoność naszego algorytmu jest <strong>logarytmiczna</strong>. Zadanie gotowe!</p>\n<h3>Dzięki za uwagę, Kamil Michna ;)</h3>"}
{"componentChunkName":"component---src-templates-post-js","path":"/posts/matura-2019-ulubione-cyfry","webpackCompilationHash":"27fcdc6df793f148cf4d","result":{"data":{"allWordpressPost":{"edges":[{"node":{"date":"30, Mar, 2020","title":"Matura 2019 &#8211; ulubione&nbsp;cyfry","content":"\n<h1>Matura 2019 &#8211; Ulubione cyfry</h1>\n\n\n\n<p>Cze! Nowa seria polega bdzie na wsp贸lnym rozwizywaniu zada z matury rozszerzonej z informatyki, do kt贸rej wanie si przygotowuj. Wykorzystywa bdziemy jzyk&nbsp;<strong>Python</strong>&nbsp;&#8211; jako jeden z dostpnych obecnie. Zaczniemy od tegorocznej matury. Arkusze matury mo偶esz znale藕 na stronie Centralnej Komisji Egzaminacyjnej:&nbsp;<a href=\"https://cke.gov.pl/egzamin-maturalny/egzamin-w-nowej-formule/arkusze/2019-2/\">Link</a>.</p>\n\n\n\n<h2><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#tre%C5%9B%C4%87-zadania\"></a>Tre zadania:</h2>\n\n\n\n<p><code>Magosia i Ja lubi liczby. Magosia lubi liczby nieparzyste, a Ja lubi liczby parzyste. Ka偶de z dzieci zapisao po kilka spor贸d swoich ulubionych liczb na jednej wsp贸lnej kartce. Najpierw Magosia zapisaa wszystkie swoje liczby, a potem Ja dopisa swoje.</code>&nbsp;&#8220;Kartk&#8221; mo偶emy przedstawi jako&nbsp;<strong>tablic dwuwymiarow</strong>&nbsp;kt贸ra zawiera najpierw bli偶ej nieokrelon ilo liczb nieparzystych, a nastpnie &#8211; r贸wnie偶 nieokrelon ilo liczb parzystych. Dla przykadu, zbi贸r liczb wypisanych przez Jasia i Magosie mo偶e wyglda w ten spos贸b:&nbsp;<code>{5, 99, 3, 7, 111, 13, 4, 24, 4, 8}</code>&nbsp;Od lewej mamy zapisane liczby Magosi &#8211; nieparzyste. Naszym celem jest znalezienie pierwszej liczby Jasia &#8211; czyli pierwszej liczby parzystej. W tym przypadku jest to&nbsp;<strong>4</strong>.</p>\n\n\n\n<h2><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#zadanie-11\"></a>Zadanie 1.1:</h2>\n\n\n\n<p>` Napisz algorytm (w postaci listy krok贸w, w pseudokodzie lub w wybranym jzyku programowania), kt贸ry dla danego cigu liczb zapisanych przez dzieci znajdzie pierwsz liczb zapisan przez Jasia. Zakadamy, 偶e ka偶de z dzieci zapisao co najmniej jedn liczb.</p>\n\n\n\n<p>Przy ocenie bdzie brana pod uwag zo偶ono czasowa Twojego algorytmu. Maksymaln liczb punkt贸w uzyskasz za algorytm o zo偶onoci lepszej ni偶 liniowa.</p>\n\n\n\n<p>Uwaga: W zapisie algorytmu mo偶esz wykorzysta tylko operacje arytmetyczne (dodawanie, odejmowanie, mno偶enie, dzielenie, dzielenie cakowite, reszta z dzielenia), instrukcje por贸wnania, instrukcje sterujce i przypisania do zmiennych lub samodzielnie napisane funkcje, wykorzystujce wy偶ej wymienione operacje. ` O co chodzi? Ano mamy za zadanie napisa w&nbsp;<strong>dowolnym jzyku programowania lub pseudokodzie</strong>&nbsp;program kt贸ry w cigu liczb znajdzie nam pierwsz liczb parzyst (napisan przez Jasia). Jest to stosunkowo proste na pierwszy rzut oka, ale sprawa komplikuje si przy&nbsp;<strong>zo偶onoci obliczeniowej</strong>. Wykonajmy wic p贸ki co zadanie w najprostszy spos贸b, taki po &#8220;najmniejszej linii oporu&#8221; &#8211; najszybszy ale jednoczenie dajcy nam najmniejsz liczb punkt贸w.</p>\n\n\n\n<p>W jaki spos贸b to zrobimy? Pewnie wikszo z Was gdyby bez wzgldu na wspomnian ju偶&nbsp;<strong>zo偶ono obliczeniow</strong>&nbsp;miaa napisa wymagany algorytm zrobia by to w ten spos贸b. po prostu sprawdzamy nasz tablic od lewej do prawej, i gdy tylko natrafimy na liczb parzyst zatrzymujemy go i zwracamy wynik. U偶yjemy do tego&nbsp;<strong>ptli</strong></p>\n\n\n\n<pre class=\"wp-block-preformatted\"># u偶ywam polskiej nazwy zmiennej jedynie dla lepszej czytelnoci kodu.\nlista = [5, 99, 3, 7, 111, 13, 4, 24, 4, 8]\n\nfor liczba in lista:\n\tif liczba %2 == 0:\n\t\tprint('Pierwsza liczba parzysta to: ' + str(liczba))\n\tbreak;</pre>\n\n\n\n<p>Myl 偶e kod jest bardzo prosty &#8211; i co wa偶ne czytelny. Moglibymy r贸wnie偶 zrobi z niego funkcj kt贸ra odnajdzie pierwsz liczb parzyst dla ka偶dego zbioru liczb podanego jako argument. Do dziea!</p>\n\n\n\n<pre class=\"wp-block-preformatted\"># u偶ywam polskiej nazwy zmiennej jedynie dla lepszej czytelnoci kodu.\nlista = [5, 99, 3, 7, 111, 13, 4, 24, 4, 8]\n\ndef pierwsza_parzysta(liczby):\n\tfor liczba in liczby:\n\t\tif liczba%2 == 0:\n\t\t\treturn liczba\n\nprint('Pierwsza parzysta liczba to: '+str(pierwsza_parzysta(lista)))</pre>\n\n\n\n<p>Program w obu powy偶szych przypadkach zwr贸ci 4 &#8211; czyli dziaa. Kod jest czytelny, prosty, sukces, prawda? Ano nie. Rozwizanie jest prawidowe, ale dostalibymy za nie minimaln liczb punkt贸w.</p>\n\n\n\n<h2><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#dlaczego\"></a>Dlaczego?</h2>\n\n\n\n<p>Problemem jest wspomniana ju偶 wczeniej&nbsp;<strong>zo偶ono obliczeniowa</strong>. O co chodzi? Wa偶nym problemem w informatyce jest opisanie szybkoci danego programu. Jednak istnieje cae mn贸stwo konfiguracji sprztowych &#8211; zwyczajny pomiar czasu wykonania nie jest miarodajny. Dlatego u偶ywa si r贸偶nych sposob贸w na okrelenie szybkoci dziaania algorytmu. W skr贸cie, nasz algorytm ma obecnie zo偶ono liniow. Dlaczego? Ano je偶eli narysowalibymy sobie wykres iloci przeprowadzonych operacji do iloci liczb to bya by to linia prosta &#8211; im wicej liczb tym wicej razy musimy iterowa przez tablic. Lepszym rozwizaniem jest zastosowanie algorytmu o zo偶onoci logarytmicznej. Zapisany przeze mnie w pythonie algorytm wyglda w ten spos贸b:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">A = [1,2,5,6,22,44,18]\n\nwhile True:\n\tn = len(A)\n\tif A[n//2] %2 == 0  and A[n//2-1] %2 == 1:\n\t\tprint(A[n//2]) #Otrzymalimy wynik, wywietlamy go\n\t\tbreak\n\telif A[n//2] %2 == 1  and A[n//2-1] %2 == 1:\n\t\tA = A[n//2:]\n\telif A[n//2] %2 == 0  and A[n//2-1] %2 ==0:\n\tA = A[:n//2]</pre>\n\n\n\n<p>Co dzieje si w tym programie? Za贸偶my 偶e mamy tablic:&nbsp;<code>1,2,5,6,22,44,18</code>. Program znajduje jej rodek, czyli&nbsp;<code>6</code>. Nastpnie sprawdza warto elementu wczeniejszego, czyli&nbsp;<code>5</code>. Je偶eli nasz parzysty rodek jest poprzedzony liczb nieparzyst, oznacza to 偶e znale藕limy poszukiwan przez nas warto. Sprawd藕my teraz dziaanie algorytmu na innym zbiorze danych, na przykad podanym wczeniej:&nbsp;<code>5, 99, 3, 7, 111, 13, 4, 24, 4, 8</code>. Program rodek tablicy znajduje wzorem&nbsp;<code>dugo tablicy//2</code>, czyli w naszym przypadku jest to indeks 5 &#8211; warto&nbsp;<code>13</code>. Program sprawdza element poprzedzajcy &#8211;&nbsp;<code>111</code>. Instrukcja warunkowa nr 2 (rodkowy elif) m贸wi mu, 偶e w takim przypadku ma uci pierwsz poow naszej tabeli &#8211; element szukany na pewno znajduje si bardziej na prawo! Nastpuje kolejna iteracja. Tym razem za rodek zostaje przyjty element o indeksie&nbsp;<code>2</code>, a A ma teraz elementy:&nbsp;<code>13, 4, 24, 4, 8</code>. 24 jest podzielne przez 2, element poprzedzajcy &#8211; 4 &#8211; te偶. W tym wypadku odcinamy wszystko na prawo, razem z 24. Pozostaje nam&nbsp;<code>[13,4]</code>, z kt贸rego program zwraca warto 4 dziki pierwszej instrukcji warunkowej. I voil! U偶ylimy tutaj wariacji algorytmu&nbsp;<code>binary search</code>, kt贸ry wedug Wikipedii ma zo偶ono&nbsp;<strong>O(log n)</strong>. Oznacza to 偶e&nbsp;<strong>w przypadku miliona element贸w w tablicy program musiaby sprawdzi maksymalnie 20 element贸w aby znale藕 po偶dany, a nasz wczeniejszy algorytm &#8211; w najgorszym wypadku &#8211; a偶 milion!</strong>&nbsp;To gigantyczna przepa w zo偶onoci, wa偶na zwaszcza w du偶ych zbiorach danych. Nastpnie pozostao nam udzieli odpowiedzi &#8211; zo偶ono naszego algorytmu jest&nbsp;<strong>logarytmiczna</strong>. Zadanie gotowe!</p>\n\n\n\n<h3><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#dzi%C4%99ki-za-uwag%C4%99-kamil-michna-\"></a>Dziki za uwag, Kamil Michna </h3>\n","jetpack_featured_media_url":"","categories":[{"name":"Uncategorized"}]}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"matura-2019-ulubione-cyfry"}}}
{"componentChunkName":"component---src-templates-post-js","path":"/posts/matura-2019-ulubione-cyfry","webpackCompilationHash":"27fcdc6df793f148cf4d","result":{"data":{"allWordpressPost":{"edges":[{"node":{"date":"30, Mar, 2020","title":"Matura 2019 &#8211; ulubione&nbsp;cyfry","content":"\n<h1>Matura 2019 &#8211; Ulubione cyfry</h1>\n\n\n\n<p>Cześć! Nowa seria polegać będzie na wspólnym rozwiązywaniu zadań z matury rozszerzonej z informatyki, do której właśnie się przygotowuję. Wykorzystywać będziemy język&nbsp;<strong>Python</strong>&nbsp;&#8211; jako jeden z dostępnych obecnie. Zaczniemy od tegorocznej matury. Arkusze matury możesz znaleźć na stronie Centralnej Komisji Egzaminacyjnej:&nbsp;<a href=\"https://cke.gov.pl/egzamin-maturalny/egzamin-w-nowej-formule/arkusze/2019-2/\">Link</a>.</p>\n\n\n\n<h2><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#tre%C5%9B%C4%87-zadania\"></a>Treść zadania:</h2>\n\n\n\n<p><code>Małgosia i Jaś lubią liczby. Małgosia lubi liczby nieparzyste, a Jaś lubi liczby parzyste. Każde z dzieci zapisało po kilka spośród swoich ulubionych liczb na jednej wspólnej kartce. Najpierw Małgosia zapisała wszystkie swoje liczby, a potem Jaś dopisał swoje.</code>&nbsp;&#8220;Kartkę&#8221; możemy przedstawić jako&nbsp;<strong>tablicę dwuwymiarową</strong>&nbsp;która zawiera najpierw bliżej nieokreśloną ilość liczb nieparzystych, a następnie &#8211; również nieokreśloną ilość liczb parzystych. Dla przykładu, zbiór liczb wypisanych przez Jasia i Małgosie może wyglądać w ten sposób:&nbsp;<code>{5, 99, 3, 7, 111, 13, 4, 24, 4, 8}</code>&nbsp;Od lewej mamy zapisane liczby Małgosi &#8211; nieparzyste. Naszym celem jest znalezienie pierwszej liczby Jasia &#8211; czyli pierwszej liczby parzystej. W tym przypadku jest to&nbsp;<strong>4</strong>.</p>\n\n\n\n<h2><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#zadanie-11\"></a>Zadanie 1.1:</h2>\n\n\n\n<p>` Napisz algorytm (w postaci listy kroków, w pseudokodzie lub w wybranym języku programowania), który dla danego ciągu liczb zapisanych przez dzieci znajdzie pierwszą liczbę zapisaną przez Jasia. Zakładamy, że każde z dzieci zapisało co najmniej jedną liczbę.</p>\n\n\n\n<p>Przy ocenie będzie brana pod uwagę złożoność czasowa Twojego algorytmu. Maksymalną liczbę punktów uzyskasz za algorytm o złożoności lepszej niż liniowa.</p>\n\n\n\n<p>Uwaga: W zapisie algorytmu możesz wykorzystać tylko operacje arytmetyczne (dodawanie, odejmowanie, mnożenie, dzielenie, dzielenie całkowite, reszta z dzielenia), instrukcje porównania, instrukcje sterujące i przypisania do zmiennych lub samodzielnie napisane funkcje, wykorzystujące wyżej wymienione operacje. ` O co chodzi? Ano mamy za zadanie napisać w&nbsp;<strong>dowolnym języku programowania lub pseudokodzie</strong>&nbsp;program który w ciągu liczb znajdzie nam pierwszą liczbę parzystą (napisaną przez Jasia). Jest to stosunkowo proste na pierwszy rzut oka, ale sprawa komplikuje się przy&nbsp;<strong>złożoności obliczeniowej</strong>. Wykonajmy więc póki co zadanie w najprostszy sposób, taki po &#8220;najmniejszej linii oporu&#8221; &#8211; najszybszy ale jednocześnie dający nam najmniejszą liczbę punktów.</p>\n\n\n\n<p>W jaki sposób to zrobimy? Pewnie większość z Was gdyby bez względu na wspomnianą już&nbsp;<strong>złożoność obliczeniową</strong>&nbsp;miała napisać wymagany algorytm zrobiła by to w ten sposób. po prostu sprawdzamy naszą tablicę od lewej do prawej, i gdy tylko natrafimy na liczbę parzystą zatrzymujemy go i zwracamy wynik. Użyjemy do tego&nbsp;<strong>pętli</strong></p>\n\n\n\n<pre class=\"wp-block-preformatted\"># używam polskiej nazwy zmiennej jedynie dla lepszej czytelności kodu.\nlista = [5, 99, 3, 7, 111, 13, 4, 24, 4, 8]\n\nfor liczba in lista:\n\tif liczba %2 == 0:\n\t\tprint('Pierwsza liczba parzysta to: ' + str(liczba))\n\tbreak;</pre>\n\n\n\n<p>Myślę że kod jest bardzo prosty &#8211; i co ważne czytelny. Moglibyśmy również zrobić z niego funkcję która odnajdzie pierwszą liczbę parzystą dla każdego zbioru liczb podanego jako argument. Do dzieła!</p>\n\n\n\n<pre class=\"wp-block-preformatted\"># używam polskiej nazwy zmiennej jedynie dla lepszej czytelności kodu.\nlista = [5, 99, 3, 7, 111, 13, 4, 24, 4, 8]\n\ndef pierwsza_parzysta(liczby):\n\tfor liczba in liczby:\n\t\tif liczba%2 == 0:\n\t\t\treturn liczba\n\nprint('Pierwsza parzysta liczba to: '+str(pierwsza_parzysta(lista)))</pre>\n\n\n\n<p>Program w obu powyższych przypadkach zwróci 4 &#8211; czyli działa. Kod jest czytelny, prosty, sukces, prawda? Ano nie. Rozwiązanie jest prawidłowe, ale dostalibyśmy za nie minimalną liczbę punktów.</p>\n\n\n\n<h2><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#dlaczego\"></a>Dlaczego?</h2>\n\n\n\n<p>Problemem jest wspomniana już wcześniej&nbsp;<strong>złożoność obliczeniowa</strong>. O co chodzi? Ważnym problemem w informatyce jest opisanie szybkości danego programu. Jednak istnieje całe mnóstwo konfiguracji sprzętowych &#8211; zwyczajny pomiar czasu wykonania nie jest miarodajny. Dlatego używa się różnych sposobów na określenie szybkości działania algorytmu. W skrócie, nasz algorytm ma obecnie złożoność liniową. Dlaczego? Ano jeżeli narysowalibyśmy sobie wykres ilości przeprowadzonych operacji do ilości liczb to była by to linia prosta &#8211; im więcej liczb tym więcej razy musimy iterować przez tablicę. Lepszym rozwiązaniem jest zastosowanie algorytmu o złożoności logarytmicznej. Zapisany przeze mnie w pythonie algorytm wygląda w ten sposób:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">A = [1,2,5,6,22,44,18]\n\nwhile True:\n\tn = len(A)\n\tif A[n//2] %2 == 0  and A[n//2-1] %2 == 1:\n\t\tprint(A[n//2]) #Otrzymaliśmy wynik, wyświetlamy go\n\t\tbreak\n\telif A[n//2] %2 == 1  and A[n//2-1] %2 == 1:\n\t\tA = A[n//2:]\n\telif A[n//2] %2 == 0  and A[n//2-1] %2 ==0:\n\tA = A[:n//2]</pre>\n\n\n\n<p>Co dzieje się w tym programie? Załóżmy że mamy tablicę:&nbsp;<code>1,2,5,6,22,44,18</code>. Program znajduje jej środek, czyli&nbsp;<code>6</code>. Następnie sprawdza wartość elementu wcześniejszego, czyli&nbsp;<code>5</code>. Jeżeli nasz parzysty środek jest poprzedzony liczbą nieparzystą, oznacza to że znaleźliśmy poszukiwaną przez nas wartość. Sprawdźmy teraz działanie algorytmu na innym zbiorze danych, na przykład podanym wcześniej:&nbsp;<code>5, 99, 3, 7, 111, 13, 4, 24, 4, 8</code>. Program środek tablicy znajduje wzorem&nbsp;<code>długość tablicy//2</code>, czyli w naszym przypadku jest to indeks 5 &#8211; wartość&nbsp;<code>13</code>. Program sprawdza element poprzedzający &#8211;&nbsp;<code>111</code>. Instrukcja warunkowa nr 2 (środkowy elif) mówi mu, że w takim przypadku ma uciąć pierwszą połowę naszej tabeli &#8211; element szukany na pewno znajduje się bardziej na prawo! Następuje kolejna iteracja. Tym razem za środek zostaje przyjęty element o indeksie&nbsp;<code>2</code>, a A ma teraz elementy:&nbsp;<code>13, 4, 24, 4, 8</code>. 24 jest podzielne przez 2, element poprzedzający &#8211; 4 &#8211; też. W tym wypadku odcinamy wszystko na prawo, razem z 24. Pozostaje nam&nbsp;<code>[13,4]</code>, z którego program zwraca wartość 4 dzięki pierwszej instrukcji warunkowej. I voilà! Użyliśmy tutaj wariacji algorytmu&nbsp;<code>binary search</code>, który według Wikipedii ma złożoność&nbsp;<strong>O(log n)</strong>. Oznacza to że&nbsp;<strong>w przypadku miliona elementów w tablicy program musiałby sprawdzić maksymalnie 20 elementów aby znaleźć pożądany, a nasz wcześniejszy algorytm &#8211; w najgorszym wypadku &#8211; aż milion!</strong>&nbsp;To gigantyczna przepaść w złożoności, ważna zwłaszcza w dużych zbiorach danych. Następnie pozostało nam udzielić odpowiedzi &#8211; złożoność naszego algorytmu jest&nbsp;<strong>logarytmiczna</strong>. Zadanie gotowe!</p>\n\n\n\n<h3><a href=\"https://github.com/kamilmichna/kamilmichna.github.io/blob/stable/src/posts/2019/8/matura-2019-1.md#dzi%C4%99ki-za-uwag%C4%99-kamil-michna-\"></a>Dzięki za uwagę, Kamil Michna 😉</h3>\n","jetpack_featured_media_url":"","categories":[{"name":"Uncategorized"}]}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"matura-2019-ulubione-cyfry"}}}